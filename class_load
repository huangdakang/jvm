
》》》》》》》》》》》》》》》》》》》》类的加载机制
　　　　　　　　虚拟机把描述累的数据从class文件加载到内存，并进行数据校验，转化解析和初始化，最终
　　　　　　　　形成可以被虚拟机直接使用的Ｊａｖａ类型
　　　　　
　　　　　
　　　　　　　　类的加载、链接、初始化的过程在程序的运行起进行完成，动态加载就是运行期动态加载和动态
链接的这个个点来完成的。
　　　　　　　　在实际情况中，每个类代表这一个Ｊａｖａ语言中的类或接口
　　　　　　　　一串ｃｌａｓｓ文件与前面约定的一致
》》》》》》》》》》》》》》》》》》》》》》》类的加载时机
　　　　　　　　　加载、验证、准备、解析、初始化、使用、卸载
　　　　　　　　　验证、准备、解析称为链接


　　　　　　　　　开始加载　
　　　　　　　　　　　　１　ｎｅｗ　ｇｅｔＳＴａｔｉｃ　ｐｕｔＳｔａｔｉｃ　ｉｎｖｉｌｅＳｔａｔｅｉｃ
　　　　　　　　　　　　２　　使用Ｊａｖａ.lang.reflect包的方法进行调用时　需要初始化
　　　　　　　　　　　　　　　　　　　　　  3　当初始化一个类时　发现其父类没有进行出化　先要初始化起父类
　　　　　　　　　　　　　　　　　　　　　　4 启动时要指定一个执行的主类，虚拟机西安哟啊初始化这个主类
　　　　　　　　　　　　　　　　　　　　　　5 java.lang.invoke.MethodHandler 实例最后的解析结果ref_getStatic 		ref_pubStatic,ref_invokeStaatic 方法的句柄，并且这个方法对应的类没有初始化　应该先初始化这个主类
　　　　　　　　　　　　对于静态字段，只有直接定仪这个字段的类才会被出事化，因此子类来引用父类的静态
　　　　　　　　　　　　　引用　之后触发父类的引用而不会触发子类的引用

　　　　　　　　　　　　－XX：＋tranceClassLoading参数观察此操作会导致子类的加载

　　》》》》》》》》》》》》》》》》》》》加载
　　　　　１　类的权限定名来加载定义此类的二进制字节流
　　　　　２将这个字节流所代表的静态存储结构转化为方法去运行时数据结构
　　　　　３在内存中生成一个类代表这个类的java.lang.class对象，作为方法区这个类的访问入口




　　　　虚拟机对这三点要求并不算具体 二进制流要从class文件中获取　斌没有规定class文件从何来
　　　　　　　　　１　zip 包中读取　　jar ear war
                  2 从网路中获取　　　applet
                  3　运行时计算生成　动态代理　　java.lang.relfecproxy　
                4其他文件生成，典型的场景jsp应用
　　　　　　　　　　　　5 数据库

　　　　　　　　　相对于类加载过程的其他阶段，一个非数组类的加载阶段是开发人员可控性最强的
　　　　　　　　应为可以使用系统提供的类加载器来执行，也可是使用用户自定义了类加载器
　　　　　　　　　　　　数组是jａｖａ虚拟机直接创建的　但是数组中的元素和类加载器还有密切的关系


　　　　　　　　　　　若果数组的组件类型是引用类型就递归时候要给你类加载起去加载
　　　　　　　　　若果数组组件类型不是应用类型，Ｊａｖａ虚拟机就是吧数组c标记为与引导类加载器关联
　　　　　　　　　　　　数组类的可见性与其组件类型一直

　　　　　　　　　　　　　类加载完后　　按虚拟机需要的规格存储到方法区中

　　　　　　　　　如果一个同名字段　出现在c的接口和弗雷中　或者同事在自己或父类的过个接口中出现　
　　　　　　　　　　　　　编译器可能拒绝编译


》》》》》》》》》》》》》》》》》》》》》》》》》初始化过程
　　　　　clinit方法是由编译器自动收集类中的类变量的赋值动作和静态语句块中的语句合并产生的编译器收集的
顺序由语句在源文件中出现的顺序决定，静态语句块只能访问到定义到静态语句块之前的变量，定义在之后的变亮
　　　　在前面的语句快可以赋值但是无法访问
　　　　　　　clinit　方法与类的构造函数不同，她不需要显示的调用父类的构造函数　虚拟机会保证在自雷的clinit执行之前父累的已经执行完毕
　　　　　　　　clinit　方法先执行，　也就一以为这父累的静态语句块要优先于子类的变量的复制操作
　     client方法对类或接口来书ｂｉｎｄｅｒ不是必需的　如果一个类中没有静态语句块，也没变量的赋值操作
　　　　那就不生成类的clinit方法
　　　　接口中不能使用静态语句块　但任由变量初始化赋值操作　因此接口和类都会生成clinit方法
　　　　　虚拟级会保证一个类的clinit方法在多个线程环境张被正确的加锁同步




》》》》》》》》》》》》》》》》》》》》》》》》》》》》类的加载器
　　　　　通过一个类的全限定名来获取描述此类的二进值

  ３中类加载器
　启动类加载器：负责在存放在Ｊａｖａｈｏｍｅ、lib　目录中　或被xbootclasspath参数所指定的，并且被Ｊａｖ虚拟机是别的类库加载到虚拟机内存中　　无法被Ｊａｖａ程序直接应用　　自定义　委托給引导类加载起
　　扩展类加载器：开发这可以直接使用扩展类加载器　　ext目录下
　　　应用程序类加载器：负责加载用户类路径上的类加载器


　　　　类加载之间的这种层次关系　叫做双亲委派模型：　要求都要有父类加载器　　一般使用组合的方式来实现
       加载时先委派給父类　如果父类　都无法加载　　然后子类才加载

　　　　这样的好处是　使Ｊａｖａ类也和类加载器一样有了优先级的层次关系

　　　　　　　　双亲委派的对保证Ｊａｖａ程序的稳定运行很重要　　实现非常简单　都集中在loadclass中


》》》》》》》》》》》》》》》》》》》》》》》》》》》》》破坏双亲委派模型
　　　　

　　双亲委派模型不是一个强制性的约束模型，　而是java设计者推荐給开发这的类加载器实现
　　　　　　　
　　　　　　　　　　　　　　　　　　　　　
　　　　　　　　　　
