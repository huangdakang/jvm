  栈帧　　是用于虚拟机进行方法调用和方法执行的数据结构　　他是虚拟机运行是数据区中的虚拟机栈的栈元素

　　　　　　　　　　存储局部变量表　　操作数栈　　动态链接　　和方法的返回值
　　　　　　每一个方法开始执行到执行完毕的过程都是一个栈针在虚拟机展中出栈和入栈的过程


　　　　　　一个栈针需要分配多少内存　不会受到程序运行时　变量数据的印象　　仅仅取决与虚拟机的实现
　　　　　　调用连很长，横多方法都处于运行状态　但是只有在栈顶的栈帧是有效的－－－－－当前栈帧
　　　　　　字码指令只对当前栈帧进行操作节



》》》》》》》》》》》》》》》》》》》局部变量表
　　　　　　是一组变量的存储空间，用于存放方法参数和方法内部定义的局部变量表　　在编译了Ｃａｓｓ文件是
　　　　　　就确定了该方法需要分配的局部变量表和最大容量
　　　　　　局部变量表的容量一变量槽为最小单位　　６４位　对其和补白的方式来看起来和３２位一直

　　　　　索引定位的方式来使用局部变量表　　索引位置从o 开始

　　　　　局部变量表中的slot是否有ｐｌａｃｅｈｏｌｄｅｒ的引用，第一次修改之后虽然离开了作用域但是
　　　斌没有对局部变量表做操作placeholder 原本占有的ｓｌｏｔ还没有被其他对象所复用　　所以gc-root
    　一部风的局部变量表仍对他保持这关联
　　　　不使用的对象因手动赋值为null
　　　　　　　

　　　　置为null  是建立在字节码执行引擎的概念上

        以恰当的变量作用域来控制变量回收的时间才是最优雅的
　　　　　虚拟机使用的解释器执行时　　通常和概念模型还是恒接近的　jit编译之后　null 就会被取消掉
　　　　　此时对象设置为null　就没有实际意义了
》》》》》》》》》》》》》》》》》》》》》》》》》》操作数栈
　　　　　　　　　　操作数栈也称　操作栈
　　　　　　　　　ｃｏｄｅ属性的max_stacks中

》》》》》》》》》》》》》》》》》》》》》》》》》》》动态链接
　　　　　　　　　　静态解析　　动态链接

》》》》》》》》》》》》》》》》》》》》》》》》》》》》方法的返回地址


　　　　　　方法的退出　第一中Ｌ遇到任意方法返回的字节码指令
　　　　　　　　　第二种　异常
　　　　　　　　退出后都要返回到调用的位置，程序才能顺利执行，当前的栈帧出栈
》》》》》》》》》》》》》》》》》》》》》》》》》》》》》附加信息


》》》》》》》》》》》》》》》》》》》》方法的调用

》》》》》》》》》》》》》》》》》》》》》》》》分派

　　　　　human的类型称为静态类型或者外观类型　　　man 称为实际类型
　　　静态类型和实际类型在程序中都可以发生一些变化　　静态类型仅仅只是在使用时发生变化
　　　　　本身的静态类型不会变化，并且最终静态类型在编译期可知，实际类型的变化结果
　　　在运行期才可以确定，编译器在编译程序的时候不并比知道一个对象的实际类型是什么
　　　　　　虚拟机在重载的时候是通过参数的静态类型而不是实际类型来作为判定的依据
　　　　并且静态类型是编译期可知的，因此在编译阶段，java编译起会根据参数的静态类型
　　　　　来决定使用那个重载的版本
　　　　　静态分派是发生在编译阶段　　因此确定静态分派的动作实际上不是由虚拟机来来执行的
　　　　　　　　
　　　　　　编译器虽然能确定出方法编译的版本　但是很多情况下变异的版本并不是唯一的
　　　　　　　往往只能确定一个更加合适的版本
　　　　　字面量不需要定义　所以字面量没有显示的静态类型　它的静态类型只能通过语言的规则
　　　　　　　　　去理解和推断

》》》》》》》》》》》》静态分派
　　　　所有依赖静态类型来定位方法执行版本的分派动作称为静态分派
　　－－－》方法的重载

　　　　　确定一个更加适合的版本

》》》》》》》》》》》》》》动态分派
　　　　　１　找到操作数栈顶的第一个元素所指向的对象是实际类型　c
          2  如果在类型c中找到与常量中的藐视和简单名称都相否的方法　　然后进行访问权限的验证
　　　　　如果通过这返回这个　方法的直接应用　查找过程结束　　若果不通过则返回java.long.illegalaccessError
          负责　按照继承关系从下往上以此对c的各个父类进行第二步的搜索和验证过程
　　　　　　　　　若果每没有找到合适的方法，则抛出java.lang.abstractMethodError
         invokevitual 指令执行的第一步是就是在运行期确定接受者的实际类型，所以两次调用
　　　　　中的invokevirtral 指令常量池中的类方法符号应用解析到不同的直接应用上

》》》》》》》》》》》》》》》》》》》》》》》单分派和多分派
　　　　　　方法的接受者与方法的参数统称为方法的宗量，
　　　　　　　　　根据分派的多种宗量，可以将分盘化为单分派和多分派
　　　　　　　　　　单分派是根据一个宗量对目标方法进行选择，多分派是根据多余一个宗量对
	　　目标方法进行选择
　　　　　　　　　静态多分派　　动态单分派
　　　　　　　内置javascript 执行引擎来方式类满足动态性的需求

》》》》》》》》》》》》》》》》》》》》》》》》》》》》虚拟机的动态分配的实现
　　　　　　虚拟机的概念模型的解析已经基本足够了　解决了虚拟机在分派中会做什么的问题
　　　　　　动态分派是非常频繁的动作，而且动态分派的方法版本选择过程需要运行时在类的方法
元数据中搜索合适的目标方法　因此在虚拟机的实际实现中基于性能的考虑，大部分
　的实现都不会真正地进行如此频繁的搜索
　　　　　　　　　　ｖｔａｂｌｅ
　　　　　　　　　虚方法表中存放这个个方法的的实际入口地址，如果没有被重写，那子类的虚方法
　　　　表里的入口地址　和弗雷相同的方法入口地址一致，都执向父类的实现入口，如果子类重写了
　　　　　　　子类方法表中的地址将会替换为子类实现版本的入口地址
　　　　　　　　

　　　　　　　　为了程序上的实现方便　具有相同的签名方法　　一样的索引序号　当类型进行
　　　　变换的时　，　仅需要变更要查找的方法表就可以从不同的虚方法表中的索引转化出需要　的入
　　　　　入口地址
　　　　　　　　　方法表一般在类加载的链接阶段进行出事化　准备类类的变量初始化后　虚拟机
　　　　　　会吧该类的方法表也初始化完毕


　　　　　　　　　　　　还有内联缓存　和基于类性继承关系分析技术和守护内联的激进优化来获得更高
　　　　　　　更高的性能


》》》》》》》》》》》》》》》》》》》》》》》》》动态类型语言的支持
　　　　　　　invokeDynamic
》》》》》》》》》》》》》》》》》》》》》》》》》动态类型语言
　　　　　　　　类型检车的而主题过程实在运行起而不是在编译期

　　　　　　　　java语言的编译期已将print()方法完整的符号引用生成出来，作为方法调用指令生成出来
　　　　　　存发放到calss文件中
　　　　　　　变量无类型　而变量的值才有类型
　　各有千秋


》》》》》》》》》》》》》》》》》》》》》》》》》１．７与动态类型

　　　　　　在同一个虚拟机上达到静态语言的严谨性和动态语言的的灵活性，这是一件很美妙的事情
》》》》》》》》》》》》》》》》》》》》》》》》》》》》java.lang.invoke
           提供了动态的确定目标方法的机制　称为method handler 这种


　　　　　　　　　1本质上讲　reflection methodhandler的机制都是在模拟方法的调用
　　　　　　　　　　　　　　　　refletction 是模拟java代码层的方法调用meothod是模拟字节码层的方法调用
　　　　　　　　　　　　　　　　findStatic findVirtual findSpecial 

         2 reflect 中的java.lang.reflect.method　远比methodhandler机制中的java　lang.invoke
        method 包喊的信息多　前者是全面映射　后者只是方法的相关信息　　　
　　　　　　　reflectction  是重量级的　　而method 是轻量级的

　　　　　　　　3由于MethodHandler是对字节码的方法指令调用的模拟，理论上虚拟机在这方面的各种优化
　　　　　　　　method 也应该采取相应的思路去支持　　通过反射则不行

》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》invokedynamic指令


》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》掌控方法的指派规则
　　inokedynamic  指令与其他４条invoke 指令最大的差别就是它的分派逻辑不是有须虚拟机决定的
　　而是由程序员决定的


》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》基于栈的字节码执行引擎
　　　　虚拟机是如何执行方法中的字节码指令的
　　　　　　　　　　　解释执行和编译执行两种方式

　　　　　　　　　　　　　程序源码　　词法分析　　单词流　语法分析　抽象语法树
　　　　　　　　　－－－－指令流（可选）　解释器－－－解释执行
　　　　　　　　－－－－－优化器－－－－中间代码－－生成器　－－－目标代码

　　　　　　　　　　javac编译器完成了程序代码经过有语法分析　此法分析到抽象语法树　在遍历生成线性字节码
　　　　　流的过程，因为这部分动作是在java　虚拟机之外进行的 而解释器在虚拟机的内部　　
         java　程序的编译就是半独立实现的　　


　　　　　　
　　　

　　　　

　　　　　

